## 缺陷检测解决策略之三频域+空域_03（lcd显示屏纹理缺陷检测）

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c3c45d285b9046399524290ff95a3f96.png)

```cpp
* 设置显示模式
dev_set_draw ('margin')

* 读取图像
read_image (Image, 'lcd/mura_defects_texture_01')


decompose3 (Image, R, G, B)
* 频域：对背景增强， 

* 使用差分：把原图和增强后背景图相减，获取缺陷增强后的图像

* blob分析，进行缺陷的提取。（分水岭分割+计算灰度能量特征）


* 傅里叶变换：空域转频域
fft_generic (B, ImageFFT, 'to_freq', -1, 'sqrt', 'dc_center', 'complex')

* 获取图像大小
get_image_size (B, Width, Height)
* 高斯滤波核
gen_gauss_filter (ImageGauss, 50, 50, 0, 'none', 'dc_center', Width, Height)
* 滤波操作
convol_fft (ImageFFT, ImageGauss, ImageConvol)
* 反傅里叶变换
fft_generic (ImageConvol, ImageFFT1, 'from_freq', 1, 'sqrt', 'dc_center', 'byte')

* 差分，缺陷增强显示
sub_image (B, ImageFFT1, ImageSub, 3, 100)

median_image (ImageSub, ImageMedian, 'circle', 9, 'mirrored')

***法1：直接阈值分割
threshold (ImageMedian, Region, 0, 60)

* 打散
connection (Region, ConnectedRegions)

* 开操作，去杂质
opening_circle (ConnectedRegions, RegionOpening, 5.5)

count_obj (RegionOpening, Number)

if(Number>0)
    dev_get_window (WindowHandle)
    disp_message (WindowHandle, 'NG', 'window', 12, 12, 'red', 'true')
endif


***法2： 分水岭分割
* 分水岭分割
* 阈值参数说明：若两相邻流域的最小灰度差小于阈值（如20），则认为它们属于同一区域，合并为一个流域。
watersheds_threshold (ImageMedian, Basins, 20)

* 计算每个区域的灰度能量
* Energy 统计灰度特征，灰度越低，值越低
* 找到Energy最低的值
* 设置合理的阈值，进去缺陷提取
cooc_feature_image (Basins, ImageMedian, 6, 0, Energy, Correlation, Homogeneity, Contrast)

tuple_min (Energy, Min)

Mark := Energy[<=] 0.032

select_mask_obj (Basins, SelectedObjects, Mark)
count_obj (SelectedObjects, Number)

if(Number>0)
    dev_get_window (WindowHandle)
    disp_message (WindowHandle, 'NG', 'window', 12, 12, 'red', 'true')
endif
```

```cpp
* estimate_background_illumination (Image, ImageFFT, ImageGauss, ImageConvol, IlluminationImage, Width, Height)





* 关闭窗口
dev_close_window ()
dev_update_off ()
Path := 'lcd/mura_defects_texture_'
* 读取图片
read_image (Image, Path + '01')
* 获取图像大小
get_image_size (Image, Width, Height)
* 设置窗体显示
dev_open_window (0, 0, 640, 480, 'black', WindowHandle)
set_display_font (WindowHandle, 14, 'mono', 'true', 'false')
dev_set_draw ('margin')
dev_set_line_width (3)
dev_set_color ('red')
for F := 1 to 2 by 1
    * 读取图像
    
    read_image (Image, Path + F$'.2i')
    * 分解成三个通道
    decompose3 (Image, R, G, B)
    * 增强缺陷显示
    estimate_background_illumination (B, ImageFFT1, ImageGauss, ImageConvol, IlluminationImage, Width, Height)

*     estimate_background_illumination (B, ImageFFT1)
    * 图像相减
    sub_image (B, IlluminationImage, ImageSub, 2, 100)
    * 中值滤波
    median_image (ImageSub, ImageMedian, 'circle', 9, 'mirrored')
    * 图像分割
    * 阈值参数说明：若两相邻流域的最小灰度差小于阈值（如20），则认为它们属于同一区域，合并为一个流域。
    watersheds_threshold (ImageMedian, Basins, 20)
    
    *作用：通过阈值实现图像的分水岭算法分割
    
    *分水岭算法主要用于图像的分割，如果目标物体是连接在一起的，则分割起来会很困难。此时经常采用分水岭分割算法，会得到比较好的效果。
    
    *分水岭算法是一种典型的基于边缘的图像分割算法，通过寻找区域之间的分界线，对图像进行分割。“分水岭”这个名字与一种地貌特点有关，它的思想是，把图像的灰度看作一张地形图，其中像素的灰度表示该地点的高度。灰度值低的区域是低地，灰度值越高，地势越高。
    
    *低地聚集的地方如同一块盆地，如果模拟向整片区域注水，那么每块盆地将成为一个单独的积水区，即图像上的分割区域，盆地与盆地之间的边界就是区域的边界。随着注水的量越来越多，盆地的积水面积会不断扩大，边界区域则会越来越小，最后形成的分割边界就是分水岭。

    * 计算共现矩阵并导出其灰度值特征。（计算能量分布，灰度低的，能量低）
    cooc_feature_image (Basins, ImageMedian, 6, 0, Energy, Correlation, Homogeneity, Contrast)
    * 计算掩膜
    Mask := Energy [<=] 0.05
    * 选择缺陷
    select_mask_obj (Basins, Defects, Mask)
    * 图像显示
    dev_display (Image)
    dev_display (Defects)
    * 计算缺陷个数
    count_obj (Defects, NDefects)
    * 显示结果信息
    disp_message (WindowHandle, NDefects + ' \'mura\' defects detected', 'window', 12, 12, 'red', 'true')
    if (F < 2)
        disp_continue_message (WindowHandle, 'black', 'true')
        stop ()
    endif
endfor


```

```cpp
* estimate_background_illumination (Image, ImageFFT, ImageGauss, ImageConvol, IlluminationImage, Width, Height)

* 关闭窗口
dev_close_window ()
dev_update_off ()
Path := 'lcd/mura_defects_texture_'
* 读取图片
read_image (Image, Path + '01')
* 获取图像大小
get_image_size (Image, Width, Height)
* 设置窗体显示
dev_open_window (0, 0, 640, 480, 'black', WindowHandle)
set_display_font (WindowHandle, 14, 'mono', 'true', 'false')
dev_set_draw ('margin')
dev_set_line_width (3)
dev_set_color ('red')
for F := 1 to 2 by 1
    * 读取图像
    
    read_image (Image, Path + F$'.2i')
    * 分解成三个通道
    decompose3 (Image, R, G, B)
    * 增强缺陷显示
    estimate_background_illumination (B, ImageFFT1, ImageGauss, ImageConvol, IlluminationImage, Width, Height)

*     estimate_background_illumination (B, ImageFFT1)
    * 图像相减
    sub_image (B, IlluminationImage, ImageSub, 2, 100)
    * 中值滤波
    median_image (ImageSub, ImageMedian, 'circle', 9, 'mirrored')
    * 图像分割
    watersheds_threshold (ImageMedian, Basins, 20)
    
    *作用：通过阈值实现图像的分水岭算法分割
    
    *分水岭算法主要用于图像的分割，如果目标物体是连接在一起的，则分割起来会很困难。此时经常采用分水岭分割算法，会得到比较好的效果。
    
    *分水岭算法是一种典型的基于边缘的图像分割算法，通过寻找区域之间的分界线，对图像进行分割。“分水岭”这个名字与一种地貌特点有关，它的思想是，把图像的灰度看作一张地形图，其中像素的灰度表示该地点的高度。灰度值低的区域是低地，灰度值越高，地势越高。
    
    *低地聚集的地方如同一块盆地，如果模拟向整片区域注水，那么每块盆地将成为一个单独的积水区，即图像上的分割区域，盆地与盆地之间的边界就是区域的边界。随着注水的量越来越多，盆地的积水面积会不断扩大，边界区域则会越来越小，最后形成的分割边界就是分水岭。

    * 计算共现矩阵并导出其灰度值特征。（计算能量分布，灰度低的，能量低）
    cooc_feature_image (Basins, ImageMedian, 6, 0, Energy, Correlation, Homogeneity, Contrast)
    * 计算掩膜
    Mask := Energy [<=] 0.05
    * 选择缺陷
    select_mask_obj (Basins, Defects, Mask)
    * 图像显示
    dev_display (Image)
    dev_display (Defects)
    * 计算缺陷个数
    count_obj (Defects, NDefects)
    * 显示结果信息
    disp_message (WindowHandle, NDefects + ' \'mura\' defects detected', 'window', 12, 12, 'red', 'true')
    if (F < 2)
        disp_continue_message (WindowHandle, 'black', 'true')
        stop ()
    endif
endfor

```

```cpp

get_image_size (Image, Width, Height)
*2.傅里叶变换，空间域转频域
rft_generic (Image, ImageFFT, 'to_freq', 'none', 'complex', Width)
*3.生成对应的滤波操作（低通，低频，背景）
gen_gauss_filter (ImageGauss, 50, 50, 0, 'n', 'rft', Width, Height)
*4.对频域进行滤波操作
convol_fft (ImageFFT, ImageGauss, ImageConvol)
*5.反傅里叶变换，频域转空间域
rft_generic (ImageConvol, IlluminationImage, 'from_freq', 'none', 'byte', Width)
return ()
return ()
```


## 方法2

```cpp
* estimate_background_illumination (Image, ImageFFT, ImageGauss, ImageConvol, IlluminationImage, Width, Height)

* 关闭窗口
dev_close_window ()
dev_update_off ()
Path := 'lcd/mura_defects_texture_'
* 读取图片
read_image (Image, Path + '01')
* 获取图像大小
get_image_size (Image, Width, Height)
* 设置窗体显示
dev_open_window (0, 0, 640, 480, 'black', WindowHandle)
set_display_font (WindowHandle, 14, 'mono', 'true', 'false')
dev_set_draw ('margin')
dev_set_line_width (3)
dev_set_color ('red')
for F := 1 to 2 by 1
    * 读取图像
    
    read_image (Image, Path + F$'.2i')
    * 分解成三个通道
    decompose3 (Image, R, G, B)
    * 增强缺陷显示
    estimate_background_illumination (B, ImageFFT1, ImageGauss, ImageConvol, IlluminationImage, Width, Height)

*     estimate_background_illumination (B, ImageFFT1)
    * 图像相减
    sub_image (B, IlluminationImage, ImageSub, 2, 100)
    * 中值滤波（去干扰）
    mean_image (ImageSub, ImageMean, 10, 10)
    * 阈值分割，提取缺陷
   threshold (ImageMean, Region, 0, 70)
    
   * 打散
    connection (Region, ConnectedRegions)
    
    * 开操作：去杂质
    opening_circle (ConnectedRegions, RegionOpening, 3.5)
    * 计算缺陷个数
    count_obj (RegionOpening, NDefects)
    * 显示结果信息
    disp_message (WindowHandle, NDefects + ' \'mura\' defects detected', 'window', 12, 12, 'red', 'true')
    if (F < 2)
        disp_continue_message (WindowHandle, 'black', 'true')
        stop ()
    endif
endfor

```

